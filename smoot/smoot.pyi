from __future__ import annotations

from numbers import Real
from pathlib import Path
from typing import TYPE_CHECKING, Any
from typing_extensions import Self

if TYPE_CHECKING:
    import numpy as np
    from numpy.typing import NDArray

class SmootError(Exception): ...
class SmootParseError(Exception): ...

class UnitRegistry:
    def __init__(self) -> None: ...
    @staticmethod
    def new_from_str(data: str) -> UnitRegistry: ...
    @staticmethod
    def new_from_file(path: Path) -> UnitRegistry: ...
    @staticmethod
    def new_from_cache_or_file(cache_path: Path, file_path: Path) -> UnitRegistry: ...
    def extend(self, data: str) -> None: ...
    def get_registry_size(self) -> int: ...
    def get_all_registry_keys(self) -> list[str]: ...

# def i64_to_f64_quantity(q: I64Quantity) -> F64Quantity: ...
# def array_i64_to_f64_quantity(q: ArrayI64Quantity) -> ArrayF64Quantity: ...

def mul_unit(num: int | float, unit: Unit) -> F64Quantity: ...
def div_unit(unit: Unit, num: int | float) -> F64Quantity: ...
def rdiv_unit(num: int | float, unit: Unit) -> F64Quantity: ...
def arr_mul_unit(arr: NDArray[np.float64], unit: Unit) -> F64Quantity: ...
def arr_div_unit(unit: Unit, arr: NDArray[np.float64]) -> F64Quantity: ...
def arr_rdiv_unit(arr: NDArray[np.float64], unit: Unit) -> F64Quantity: ...

class Unit:
    @staticmethod
    def parse(s: str, registry: UnitRegistry) -> tuple[float, Unit]: ...
    @property
    def dimensionless(self) -> bool: ...
    def dimensionality(self, registry: UnitRegistry) -> dict[str, float] | None: ...
    def is_compatible_with(self, other: Self) -> bool: ...
    def is_dimensionless(self) -> bool: ...
    def to_root_units(self, registry: UnitRegistry) -> Self: ...
    def ito_root_units(self, registry: UnitRegistry) -> None: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __mul__(self, other: Self) -> Self: ...
    def __imul__(self, other: Self) -> Self: ...
    def __truediv__(self, other: Self) -> Self: ...
    def __itruediv__(self, other: Self) -> Self: ...
    def __pow__(self, p: float | int, modulo: Real | None = None) -> Self: ...
    def __ipow__(self, p: float | int, modulo: Real | None = None) -> Self: ...

class F64Quantity:
    def __init__(
        self,
        value: float,
        units: Unit | None = None,
        *,
        factor: float | None = None,
    ) -> None: ...
    @staticmethod
    def parse(expression: str, registry: UnitRegistry) -> F64Quantity: ...
    @property
    def dimensionless(self) -> bool: ...
    def dimensionality(self, registry: UnitRegistry) -> dict[str, float] | None: ...
    @property
    def unitless(self) -> bool: ...
    @property
    def m(self) -> float: ...
    @property
    def magnitude(self) -> float: ...
    @property
    def u(self) -> Unit: ...
    @property
    def units(self) -> Unit: ...
    def to(self, units: str | Unit, *, factor: float | None = None) -> Self: ...
    def ito(self, units: str | Unit, *, factor: float | None = None) -> None: ...
    def m_as(self, units: str | Unit, *, factor: float | None = None) -> float: ...
    def to_root_units(self, registry: UnitRegistry) -> Self: ...
    def ito_root_units(self, registry: UnitRegistry) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(self, other: Self | Real) -> Self: ...
    def __sub__(self, other: Self | Real) -> Self: ...
    def __mul__(self, other: Self | Real) -> Self: ...
    def __truediv__(self, other: Self | Real) -> Self: ...
    def __floordiv__(self, other: Self | Real) -> Self: ...
    def __mod__(self, other: Self | Real) -> Self: ...
    def __pow__(self, p: float | int, modulo: Real | None = None) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

# class I64Quantity:
#     def __init__(
#         self,
#         value: int,
#         units: Unit | None = None,
#         *,
#         factor: float | None = None,
#     ) -> None: ...
#     @staticmethod
#     def parse(expression: str) -> I64Quantity: ...
#     @property
#     def m(self) -> int: ...
#     @property
#     def magnitude(self) -> int: ...
#     @property
#     def u(self) -> Unit: ...
#     @property
#     def units(self) -> Unit: ...
#     def to(self, units: str | Unit, *, factor: float | None = None) -> Self: ...
#     def ito(self, units: str | Unit, *, factor: float | None = None) -> None: ...
#     def m_as(self, units: str | Unit, *, factor: float | None = None) -> int: ...
#     def __eq__(self, other: Any) -> bool: ...
#     def __add__(self, other: Self | Real) -> Self: ...
#     def __sub__(self, other: Self | Real) -> Self: ...
#     def __mul__(self, other: Self | Real) -> Self: ...
#     def __truediv__(self, other: Self | Real) -> Self: ...
#     def __floordiv__(self, other: Self | Real) -> Self: ...
#     def __mod__(self, other: Self | Real) -> Self: ...
#     def __pow__(self, p: float, modulo: Real | None = None) -> Self: ...
#     def __matmul__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __neg__(self) -> Self: ...
#     def __abs__(self) -> Self: ...
#     def __round__(self, ndigits: int | None = None) -> Self: ...
#     def __trunc__(self) -> int: ...
#     def __floor__(self) -> Self: ...
#     def __ceil__(self) -> Self: ...
#     def __int__(self) -> int: ...
#     def __float__(self) -> float: ...

class ArrayF64Quantity:
    def __init__(
        self,
        value: NDArray[np.float64],
        units: Unit | None = None,
        *,
        factor: float | None = None,
    ) -> None: ...
    @staticmethod
    def parse(expression: str, registry: UnitRegistry) -> ArrayF64Quantity: ...
    @property
    def dimensionless(self) -> bool: ...
    def dimensionality(self, registry: UnitRegistry) -> dict[str, float] | None: ...
    @property
    def unitless(self) -> bool: ...
    @property
    def m(self) -> NDArray[np.float64]: ...
    @property
    def magnitude(self) -> NDArray[np.float64]: ...
    @property
    def u(self) -> Unit: ...
    @property
    def units(self) -> Unit: ...
    def to(self, units: str | Unit, *, factor: float | None = None) -> Self: ...
    def ito(self, units: str | Unit, *, factor: float | None = None) -> None: ...
    def m_as(
        self, units: str | Unit, *, factor: float | None = None
    ) -> NDArray[np.float64]: ...
    def to_root_units(self, registry: UnitRegistry) -> Self: ...
    def ito_root_units(self, registry: UnitRegistry) -> None: ...
    def arr_pow(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __sub__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __truediv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __floordiv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mod__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __pow__(
        self,
        p: float | int | NDArray[np.float64] | NDArray[np.int64],
        modulo: Real | None = None,
    ) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

# class ArrayI64Quantity:
#     def __init__(
#         self,
#         value: NDArray[np.int64],
#         units: Unit | None = None,
#         *,
#         factor: float | None = None,
#     ) -> None: ...
#     @staticmethod
#     def parse(expression: str) -> ArrayI64Quantity: ...
#     @property
#     def m(self) -> NDArray[np.int64]: ...
#     @property
#     def magnitude(self) -> NDArray[np.int64]: ...
#     @property
#     def u(self) -> Unit: ...
#     @property
#     def units(self) -> Unit: ...
#     def to(self, units: str | Unit, *, factor: float | None = None) -> Self: ...
#     def ito(self, units: str | Unit, *, factor: float | None = None) -> None: ...
#     def m_as(
#         self, units: str | Unit, *, factor: float | None = None
#     ) -> NDArray[np.int64]: ...
#     def arr_pow(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __eq__(self, other: Any) -> bool: ...
#     def __add__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __sub__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __mul__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __truediv__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __floordiv__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __mod__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __pow__(
#         self,
#         p: float | NDArray[np.float64] | NDArray[np.int64],
#         modulo: Real | None = None,
#     ) -> Self: ...
#     def __matmul__(
#         self, other: Self | NDArray[np.float64] | NDArray[np.int64]
#     ) -> Self: ...
#     def __neg__(self) -> Self: ...
#     def __abs__(self) -> Self: ...
#     def __round__(self, ndigits: int | None = None) -> Self: ...
#     def __trunc__(self) -> int: ...
#     def __floor__(self) -> Self: ...
#     def __ceil__(self) -> Self: ...
#     def __int__(self) -> int: ...
#     def __float__(self) -> float: ...
