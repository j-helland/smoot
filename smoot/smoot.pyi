from __future__ import annotations

from numbers import Real
from typing import TYPE_CHECKING, Any
from typing_extensions import Self

if TYPE_CHECKING:
    import numpy as np
    from numpy.typing import NDArray

def get_registry_size() -> int: ...
def get_all_registry_keys() -> list[str]: ...

class F64Unit:
    @staticmethod
    def parse(s: str) -> F64Unit: ...

class F64Quantity:
    def __init__(self, value: float, units: F64Unit | None = None) -> None: ...
    @staticmethod
    def parse(expression: str) -> F64Quantity: ...
    @property
    def m(self) -> float: ...
    @property
    def magnitude(self) -> float: ...
    @property
    def u(self) -> F64Unit: ...
    @property
    def units(self) -> F64Unit: ...
    def to(self, units: str | F64Unit) -> Self: ...
    def ito(self, units: str | F64Unit) -> None: ...
    def m_as(self, units: str | F64Unit) -> float: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(self, other: Self | Real) -> Self: ...
    def __sub__(self, other: Self | Real) -> Self: ...
    def __mul__(self, other: Self | Real) -> Self: ...
    def __truediv__(self, other: Self | Real) -> Self: ...
    def __floordiv__(self, other: Self | Real) -> Self: ...
    def __mod__(self, other: Self | Real) -> Self: ...
    def __pow__(self, p: float, modulo: Real | None = None) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

class I64Quantity:
    def __init__(self, value: int, units: F64Unit | None = None) -> None: ...
    @staticmethod
    def parse(expression: str) -> I64Quantity: ...
    @property
    def m(self) -> int: ...
    @property
    def magnitude(self) -> int: ...
    @property
    def u(self) -> F64Unit: ...
    @property
    def units(self) -> F64Unit: ...
    def to(self, units: str | F64Unit) -> Self: ...
    def ito(self, units: str | F64Unit) -> None: ...
    def m_as(self, units: str | F64Unit) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(self, other: Self | Real) -> Self: ...
    def __sub__(self, other: Self | Real) -> Self: ...
    def __mul__(self, other: Self | Real) -> Self: ...
    def __truediv__(self, other: Self | Real) -> Self: ...
    def __floordiv__(self, other: Self | Real) -> Self: ...
    def __mod__(self, other: Self | Real) -> Self: ...
    def __pow__(self, p: float, modulo: Real | None = None) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

class ArrayF64Quantity:
    def __init__(
        self, value: NDArray[np.float64], units: F64Unit | None = None
    ) -> None: ...
    @staticmethod
    def parse(expression: str) -> ArrayF64Quantity: ...
    @property
    def m(self) -> NDArray[np.float64]: ...
    @property
    def magnitude(self) -> NDArray[np.float64]: ...
    @property
    def u(self) -> F64Unit: ...
    @property
    def units(self) -> F64Unit: ...
    def to(self, units: str | F64Unit) -> Self: ...
    def ito(self, units: str | F64Unit) -> None: ...
    def m_as(self, units: str | F64Unit) -> NDArray[np.float64]: ...
    def arr_pow(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __sub__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __truediv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __floordiv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mod__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __pow__(
        self,
        p: float | NDArray[np.float64] | NDArray[np.int64],
        modulo: Real | None = None,
    ) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

class ArrayI64Quantity:
    def __init__(
        self, value: NDArray[np.int64], units: F64Unit | None = None
    ) -> None: ...
    @staticmethod
    def parse(expression: str) -> ArrayI64Quantity: ...
    @property
    def m(self) -> NDArray[np.int64]: ...
    @property
    def magnitude(self) -> NDArray[np.int64]: ...
    @property
    def u(self) -> F64Unit: ...
    @property
    def units(self) -> F64Unit: ...
    def to(self, units: str | F64Unit) -> Self: ...
    def ito(self, units: str | F64Unit) -> None: ...
    def m_as(self, units: str | F64Unit) -> NDArray[np.int64]: ...
    def arr_pow(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __eq__(self, other: Any) -> bool: ...
    def __add__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __sub__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __truediv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __floordiv__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __mod__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __pow__(
        self,
        p: float | NDArray[np.float64] | NDArray[np.int64],
        modulo: Real | None = None,
    ) -> Self: ...
    def __matmul__(
        self, other: Self | NDArray[np.float64] | NDArray[np.int64]
    ) -> Self: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, ndigits: int | None = None) -> Self: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> Self: ...
    def __ceil__(self) -> Self: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
